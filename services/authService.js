import AsyncStorage from "@react-native-async-storage/async-storage";
import { AUTH_ENDPOINTS } from "./apiConfig";
import RoleService from "./roleService";

// User storage key
const USER_STORAGE_KEY = "user";
const TOKEN_STORAGE_KEY = "auth_token";

// Mock user data for development (fallback only)
const MOCK_USERS = [
  {
    id: 1,
    role_id: 4, // Customer
    full_name: "Nguy·ªÖn VƒÉn A",
    phone_number: "0123456789",
    email: "nguyenvana@email.com",
    password: "password123",
    avatar_url: "https://example.com/avatar1.jpg",
    create_at: "2024-01-01T00:00:00Z",
    deleted_at: null,
    status: "active",
  },
  {
    id: 2,
    role_id: 2, // NursingSpecialist
    full_name: "Tr·∫ßn Th·ªã B",
    phone_number: "0987654321",
    email: "tranthib@email.com",
    password: "password123",
    avatar_url: "https://example.com/avatar2.jpg",
    create_at: "2024-01-01T00:00:00Z",
    deleted_at: null,
    status: "active",
    major: "T∆∞ v·∫•n vi√™n",
    experience: "5 nƒÉm kinh nghi·ªám t∆∞ v·∫•n dinh d∆∞·ª°ng",
    slogan: "T∆∞ v·∫•n dinh d∆∞·ª°ng chuy√™n nghi·ªáp, v√¨ s·ª©c kh·ªèe c·ªßa b·∫°n",
  },
  {
    id: 3,
    role_id: 2, // NursingSpecialist
    full_name: "L√™ VƒÉn C",
    phone_number: "0123456788",
    email: "levanc@email.com",
    password: "password123",
    avatar_url: "https://example.com/avatar3.jpg",
    create_at: "2024-01-01T00:00:00Z",
    deleted_at: null,
    status: "active",
    major: "T∆∞ v·∫•n vi√™n",
    experience: "8 nƒÉm kinh nghi·ªám t∆∞ v·∫•n s·ª©c kh·ªèe",
    slogan: "ChƒÉm s√≥c s·ª©c kh·ªèe v·ªõi t√¨nh y√™u th∆∞∆°ng",
  },
];

// Network timeout (10 seconds)
const NETWORK_TIMEOUT = 10000;

class AuthService {
  // Helper function to create fetch with timeout
  async fetchWithTimeout(url, options, timeout = NETWORK_TIMEOUT) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }

  // L∆∞u th√¥ng tin user
  async saveUser(userData) {
    try {
      console.log("üîç SAVING USER DATA TO ASYNCSTORAGE");
      console.log("üîç User data to save:", userData);
      console.log("üîç User data keys:", Object.keys(userData));
      console.log("üîç User data type:", typeof userData);
      console.log(
        "üîç Role info - role_id:",
        userData.role_id,
        "roleID:",
        userData.roleID,
        "roleName:",
        userData.roleName
      );
      console.log(
        "üîç ID info - id:",
        userData.id,
        "accountID:",
        userData.accountID
      );
      console.log(
        "üîç Name info - fullName:",
        userData.fullName,
        "full_name:",
        userData.full_name
      );

      const jsonString = JSON.stringify(userData);
      console.log("üîç JSON string to save:", jsonString);
      console.log("üîç JSON string length:", jsonString.length);

      await AsyncStorage.setItem(USER_STORAGE_KEY, jsonString);
      console.log("üîç User data saved successfully to AsyncStorage");

      // Verify saved data
      const savedData = await AsyncStorage.getItem(USER_STORAGE_KEY);
      console.log("üîç Verification - saved data:", savedData);

      return true;
    } catch (error) {
      console.error("üîç Error saving user data:", error);
      return false;
    }
  }

  // L∆∞u token
  async saveToken(token) {
    try {
      await AsyncStorage.setItem(TOKEN_STORAGE_KEY, token);
      console.log("Token saved successfully");
      return true;
    } catch (error) {
      console.error("Error saving token:", error);
      return false;
    }
  }

  // L·∫•y th√¥ng tin user
  async getUser() {
    try {
      console.log("üîç GETTING USER DATA FROM ASYNCSTORAGE");
      const userData = await AsyncStorage.getItem(USER_STORAGE_KEY);
      console.log("üîç Raw user data from AsyncStorage:", userData);

      if (userData) {
        try {
          const user = JSON.parse(userData);
          console.log("üîç Parsed user data:", user);
          console.log("üîç User ID:", user.id || user.accountID);

          // N·∫øu c√≥ user ID, th·ª≠ fetch th√¥ng tin m·ªõi t·ª´ API
          if (user.id || user.accountID) {
            const userId = user.id || user.accountID;
            console.log(
              "üîç Fetching fresh user data from API for ID:",
              userId
            );

            try {
              const profileResult = await this.fetchUserProfile(
                userId
              );
              if (profileResult.success) {
                console.log(
                  "üîç Fresh user data fetched from API:",
                  profileResult.user
                );
                return profileResult.user;
              } else {
                console.log("üîç API fetch failed, using cached data");
                return user;
              }
            } catch (apiError) {
              console.log(
                "üîç API error, using cached data:",
                apiError
              );
              return user;
            }
          }

          return user;
        } catch (parseError) {
          console.error("üîç Error parsing user data:", parseError);
          return null;
        }
      }
      console.log("üîç No user data found in AsyncStorage");
      return null;
    } catch (error) {
      console.error("üîç Error getting user data:", error);
      return null;
    }
  }

  // L·∫•y token
  async getToken() {
    try {
      const token = await AsyncStorage.getItem(TOKEN_STORAGE_KEY);
      return token;
    } catch (error) {
      console.error("Error getting token:", error);
      return null;
    }
  }

  // Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p ch∆∞a
  async isLoggedIn() {
    try {
      const user = await this.getUser();
      const token = await this.getToken();
      return !!(user && token);
    } catch (error) {
      console.error("Error checking login status:", error);
      return false;
    }
  }

  // X√≥a th√¥ng tin user v√† token (ƒëƒÉng xu·∫•t)
  async logout() {
    try {
      await AsyncStorage.multiRemove([
        USER_STORAGE_KEY,
        TOKEN_STORAGE_KEY,
      ]);
      console.log("User logged out successfully");
      return true;
    } catch (error) {
      console.error("Error during logout:", error);
      return false;
    }
  }

  // ƒêƒÉng nh·∫≠p v·ªõi email/phone v√† password
  async loginWithCredentials(emailOrPhone, password) {
    try {
      console.log("Attempting to login with real API...");
      console.log("Login URL:", AUTH_ENDPOINTS.LOGIN);
      console.log("Request body:", { emailOrPhone, password });

      // G·ªçi API th·ª±c t·∫ø v·ªõi timeout
      const response = await this.fetchWithTimeout(
        AUTH_ENDPOINTS.LOGIN,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            emailOrPhoneNumber: emailOrPhone, // Thay ƒë·ªïi field name theo backend
            password: password,
          }),
        }
      );

      console.log("Response status:", response.status);
      console.log("Response headers:", response.headers);

      if (response.ok) {
        const data = await response.json();
        console.log("Login successful with real API");
        console.log("Response data:", data);
        console.log("Response data keys:", Object.keys(data));
        console.log("Response data type:", typeof data);

        if (data.user) {
          console.log("User object keys:", Object.keys(data.user));
          console.log("User role_id:", data.user.role_id);
          console.log("User roleID:", data.user.roleID);
          console.log("User id:", data.user.id);
          console.log("User accountID:", data.user.accountID);
        }
        if (data.account) {
          console.log(
            "Account object keys:",
            Object.keys(data.account)
          );
          console.log("Account role_id:", data.account.role_id);
          console.log("Account roleID:", data.account.roleID);
          console.log("Account accountID:", data.account.accountID);
          console.log("Account fullName:", data.account.fullName);
          console.log("Account email:", data.account.email);
        }
        if (data.token) {
          console.log(
            "Token received:",
            data.token.substring(0, 20) + "..."
          );
        }

        // Ki·ªÉm tra format response - c√≥ th·ªÉ kh√°c nhau t√πy backend
        if (data.user && data.token) {
          const roleName = RoleService.getRoleName(
            data.user.role_id || data.user.roleID
          );
          console.log(
            `User logged in with role: ${roleName} (ID: ${
              data.user.role_id || data.user.roleID
            })`
          );

          // Map roleID th√†nh role_id n·∫øu c·∫ßn
          const userData = {
            ...data.user,
            role_id: data.user.role_id || data.user.roleID,
          };

          await this.saveUser(userData);
          await this.saveToken(data.token);
          return { success: true, user: userData };
        } else if (data.account && data.token) {
          // Format m·ªõi: {"account": {...}, "token": "..."}
          console.log(
            `Account object keys:`,
            Object.keys(data.account)
          );
          console.log(
            `Account roleID: ${data.account.roleID}, roleName: ${data.account.roleName}`
          );

          // Map account data th√†nh user data format
          const userData = {
            id: data.account.accountID,
            accountID: data.account.accountID,
            role_id: data.account.roleID, // Map roleID th√†nh role_id
            roleID: data.account.roleID, // Gi·ªØ nguy√™n ƒë·ªÉ t∆∞∆°ng th√≠ch
            roleName: data.account.roleName, // Th√™m roleName t·ª´ backend
            fullName: data.account.fullName,
            full_name: data.account.fullName, // Map cho t∆∞∆°ng th√≠ch
            phoneNumber: data.account.phoneNumber,
            phone_number: data.account.phoneNumber, // Map cho t∆∞∆°ng th√≠ch
            email: data.account.email,
            // Th√™m c√°c field m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥
            avatar_url: data.account.avatarUrl || "",
            create_at:
              data.account.createAt || new Date().toISOString(),
            status: data.account.status || "active",
            // Th√™m c√°c field cho NursingSpecialist n·∫øu c√≥
            nursingID: data.account.nursingID,
            zoneID: data.account.zoneID,
            gender: data.account.gender,
            dateOfBirth: data.account.dateOfBirth,
            address: data.account.address,
            experience: data.account.experience,
            slogan: data.account.slogan,
            major: data.account.major,
          };

          const roleName = RoleService.getRoleName(userData.role_id);
          console.log(
            `User logged in with role: ${roleName} (ID: ${userData.role_id})`
          );

          await this.saveUser(userData);
          await this.saveToken(data.token);
          return { success: true, user: userData };
        } else if (data.id && data.email) {
          // N·∫øu response tr·ª±c ti·∫øp l√† user object
          const roleName = RoleService.getRoleName(
            data.role_id || data.roleID
          );
          console.log(
            `User logged in with role: ${roleName} (ID: ${
              data.role_id || data.roleID
            })`
          );

          // Map roleID th√†nh role_id n·∫øu c·∫ßn
          const userData = {
            ...data,
            role_id: data.role_id || data.roleID,
          };

          await this.saveUser(userData);
          await this.saveToken(data.token || "temp_token");
          return { success: true, user: userData };
        } else {
          console.log("Invalid response format:", data);
          return {
            success: false,
            error: "Invalid response format from server",
          };
        }
      } else {
        let errorMessage = "Login failed";
        try {
          const errorData = await response.json();
          console.log("Error response data:", errorData);

          // Parse validation errors
          if (errorData.errors) {
            const errorFields = Object.keys(errorData.errors);
            const errorMessages = errorFields.map((field) =>
              errorData.errors[field].join(", ")
            );
            errorMessage = errorMessages.join("; ");
          } else {
            errorMessage =
              errorData.message ||
              errorData.error ||
              `HTTP ${response.status}`;
          }
        } catch (parseError) {
          console.log("Could not parse error response");
          errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        }

        console.log("Login failed with API:", errorMessage);
        return { success: false, error: errorMessage };
      }
    } catch (error) {
      console.log(
        "API not available, falling back to mock data for login"
      );
      console.log("Error details:", error.message);

      // Fallback: S·ª≠ d·ª•ng mock data khi API kh√¥ng kh·∫£ d·ª•ng
      const user = MOCK_USERS.find(
        (u) =>
          u.email === emailOrPhone || u.phone_number === emailOrPhone
      );

      if (user && user.password === password) {
        // T·∫°o mock token
        const mockToken = `mock_token_${user.id}_${Date.now()}`;
        await this.saveUser(user);
        await this.saveToken(mockToken);
        console.log("Login successful with mock data");
        return { success: true, user: user };
      } else {
        return {
          success: false,
          error: "Email/S·ªë ƒëi·ªán tho·∫°i ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!",
        };
      }
    }
  }

  // ƒêƒÉng k√Ω t√†i kho·∫£n m·ªõi
  async register(userData) {
    try {
      console.log("Attempting to register with real API...");
      console.log("Register data:", userData);

      // S·ª≠ d·ª•ng endpoint ƒëƒÉng k√Ω customer
      const endpoint = AUTH_ENDPOINTS.REGISTER_CUSTOMER;
      console.log("Register endpoint:", endpoint);

      const response = await this.fetchWithTimeout(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(userData),
      });

      console.log("Response status:", response.status);

      if (response.ok) {
        const data = await response.json();
        console.log("Registration successful with real API");
        console.log("Response data:", data);

        // Ki·ªÉm tra format response - x·ª≠ l√Ω format m·ªõi t·ª´ backend
        if (data.account && data.message) {
          // Format: {"account": {...}, "message": "..."}
          const user = {
            id: data.account.accountID,
            full_name: data.account.fullName,
            phone_number: data.account.phoneNumber,
            email: data.account.email,
            avatar_url: data.account.avatarUrl,
            role_id: data.account.roleID,
            create_at: data.account.createAt,
            deleted_at: data.account.deletedAt,
            status: data.account.status,
          };

          // Log role information
          const roleName = RoleService.getRoleName(user.role_id);
          console.log(
            `User registered with role: ${roleName} (ID: ${user.role_id})`
          );

          // T·∫°o token t·∫°m th·ªùi (backend c√≥ th·ªÉ kh√¥ng tr·∫£ v·ªÅ token)
          const tempToken = `temp_token_${user.id}_${Date.now()}`;
          await this.saveUser(user);
          await this.saveToken(tempToken);
          return { success: true, user: user };
        } else if (data.user && data.token) {
          // Format c≈©: {"user": {...}, "token": "..."}
          const roleName = RoleService.getRoleName(data.user.role_id);
          console.log(
            `User logged in with role: ${roleName} (ID: ${data.user.role_id})`
          );

          await this.saveUser(data.user);
          await this.saveToken(data.token);
          return { success: true, user: data.user };
        } else if (data.account && data.token) {
          // Format kh√°c: {"account": {...}, "token": "..."}
          const roleName = RoleService.getRoleName(
            data.account.role_id
          );
          console.log(
            `User logged in with role: ${roleName} (ID: ${data.account.role_id})`
          );

          await this.saveUser(data.account);
          await this.saveToken(data.token);
          return { success: true, user: data.account };
        } else if (data.id && data.email) {
          // Format tr·ª±c ti·∫øp: user object
          const roleName = RoleService.getRoleName(data.role_id);
          console.log(
            `User logged in with role: ${roleName} (ID: ${data.role_id})`
          );

          await this.saveUser(data);
          await this.saveToken(data.token || "temp_token");
          return { success: true, user: data };
        } else {
          console.log("Invalid response format:", data);
          return {
            success: false,
            error: "Invalid response format from server",
          };
        }
      } else {
        let errorMessage = "Registration failed";
        try {
          const errorData = await response.json();
          console.log("Error response data:", errorData);

          // Parse validation errors
          if (errorData.errors) {
            const errorFields = Object.keys(errorData.errors);
            const errorMessages = errorFields.map((field) =>
              errorData.errors[field].join(", ")
            );
            errorMessage = errorMessages.join("; ");
          } else {
            errorMessage =
              errorData.message ||
              errorData.error ||
              `HTTP ${response.status}`;
          }
        } catch (parseError) {
          console.log("Could not parse error response");
          errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        }

        console.log("Registration failed with API:", errorMessage);
        return { success: false, error: errorMessage };
      }
    } catch (error) {
      console.log(
        "API not available, falling back to mock data for registration"
      );
      console.log("Error details:", error.message);

      // Fallback: T·∫°o mock user khi API kh√¥ng kh·∫£ d·ª•ng
      const newUser = {
        id: Date.now(),
        full_name: userData.fullName,
        phone_number: userData.phoneNumber,
        email: userData.email,
        password: userData.password,
        avatar_url: userData.avatarUrl || "",
        create_at: new Date().toISOString(),
        deleted_at: null,
        status: "active",
        role_id: 1, // Customer
      };

      // T·∫°o mock token
      const mockToken = `mock_token_${newUser.id}_${Date.now()}`;
      await this.saveUser(newUser);
      await this.saveToken(mockToken);

      console.log("Registration successful with mock data");
      return { success: true, user: newUser };
    }
  }

  // C·∫≠p nh·∫≠t th√¥ng tin user
  async updateUser(userId, userData) {
    try {
      console.log("Attempting to update user with real API...");
      console.log("User data to update:", userData);

      const token = await this.getToken();

      // Ki·ªÉm tra role ƒë·ªÉ s·ª≠ d·ª•ng endpoint ph√π h·ª£p
      if (userData.role_id === 2 || userData.roleID === 2) {
        // NursingSpecialist - s·ª≠ d·ª•ng endpoint ri√™ng
        console.log("Updating NursingSpecialist profile...");

        const nursingSpecialistData = {
          zoneID: userData.zoneID || 1,
          gender: userData.gender || "Nam",
          dateOfBirth:
            userData.dateOfBirth || new Date().toISOString(),
          fullName: userData.fullName || userData.full_name || "",
          address: userData.address || "",
          experience: userData.experience || "",
          slogan: userData.slogan || "",
          major: userData.major || "",
        };

        console.log(
          "NursingSpecialist update data:",
          nursingSpecialistData
        );

        const response = await this.fetchWithTimeout(
          AUTH_ENDPOINTS.UPDATE_NURSING_SPECIALIST(
            userData.nursingID || userId
          ),
          {
            method: "PUT",
            headers: {
              "Content-Type": "application/json-patch+json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify(nursingSpecialistData),
          }
        );

        console.log(
          "NursingSpecialist update response status:",
          response.status
        );

        if (response.ok) {
          const data = await response.json();
          console.log(
            "NursingSpecialist update successful with real API"
          );
          console.log("Response data:", data);

          // C·∫≠p nh·∫≠t user data v·ªõi response m·ªõi
          const updatedUser = {
            ...userData,
            ...data.nursingSpecialist,
            // Map l·∫°i c√°c field ƒë·ªÉ ph√π h·ª£p v·ªõi app
            fullName: data.nursingSpecialist.fullName,
            full_name: data.nursingSpecialist.fullName,
            nursingID: data.nursingSpecialist.nursingID,
            accountID: data.nursingSpecialist.accountID,
            zoneID: data.nursingSpecialist.zoneID,
            gender: data.nursingSpecialist.gender,
            dateOfBirth: data.nursingSpecialist.dateOfBirth,
            address: data.nursingSpecialist.address,
            experience: data.nursingSpecialist.experience,
            slogan: data.nursingSpecialist.slogan,
            major: data.nursingSpecialist.major,
            status: data.nursingSpecialist.status,
          };

          await this.saveUser(updatedUser);
          return { success: true, user: updatedUser };
        } else {
          let errorMessage = "NursingSpecialist update failed";
          try {
            const errorData = await response.json();
            console.log("Error response data:", errorData);
            errorMessage =
              errorData.message ||
              errorData.error ||
              `HTTP ${response.status}`;
          } catch (parseError) {
            console.log("Could not parse error response");
            errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          }

          console.log(
            "NursingSpecialist update failed with API:",
            errorMessage
          );
          return { success: false, error: errorMessage };
        }
      } else {
        // Customer ho·∫∑c role kh√°c - s·ª≠ d·ª•ng endpoint c≈©
        console.log("Updating regular user profile...");

        const response = await this.fetchWithTimeout(
          AUTH_ENDPOINTS.UPDATE_ACCOUNT(userId),
          {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify(userData),
          }
        );

        if (response.ok) {
          const updatedUser = await response.json();
          console.log("User update successful with real API");
          await this.saveUser(updatedUser);
          return { success: true, user: updatedUser };
        } else {
          const errorData = await response.json();
          console.log(
            "User update failed with API:",
            errorData.message
          );
          return { success: false, error: errorData.message };
        }
      }
    } catch (error) {
      console.log(
        "API not available, falling back to mock data for update"
      );
      console.log("Error details:", error.message);

      // Fallback: C·∫≠p nh·∫≠t user trong mock data
      const currentUser = await this.getUser();
      if (currentUser && currentUser.id === userId) {
        const updatedUser = { ...currentUser, ...userData };
        await this.saveUser(updatedUser);
        console.log("User update successful with mock data");
        return { success: true, user: updatedUser };
      } else {
        return {
          success: false,
          error: "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin user",
        };
      }
    }
  }

  // L·∫•y th√¥ng tin user t·ª´ server
  async fetchUserProfile(userId) {
    try {
      console.log(
        "Attempting to fetch user profile with real API..."
      );

      const token = await this.getToken();
      const response = await this.fetchWithTimeout(
        AUTH_ENDPOINTS.GET_ACCOUNT_BY_ID(userId),
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (response.ok) {
        const userData = await response.json();
        console.log("User profile fetch successful with real API");
        await this.saveUser(userData);
        return { success: true, user: userData };
      } else {
        console.log("User profile fetch failed with API");
        return {
          success: false,
          error: "Kh√¥ng th·ªÉ l·∫•y th√¥ng tin user",
        };
      }
    } catch (error) {
      console.log(
        "API not available, falling back to mock data for profile"
      );

      // Fallback: Tr·∫£ v·ªÅ user hi·ªán t·∫°i t·ª´ storage
      const currentUser = await this.getUser();
      if (currentUser && currentUser.id === userId) {
        console.log("User profile fetch successful with mock data");
        return { success: true, user: currentUser };
      } else {
        return {
          success: false,
          error: "Kh√¥ng th·ªÉ l·∫•y th√¥ng tin user",
        };
      }
    }
  }

  // L·∫•y th√¥ng tin chi ti·∫øt c·ªßa NursingSpecialist
  async fetchNursingSpecialistDetails(accountID) {
    try {
      console.log(
        "üîç Fetching NursingSpecialist details for accountID:",
        accountID
      );

      // Tr∆∞·ªõc ti√™n, l·∫•y nursingID t·ª´ user data hi·ªán t·∫°i
      const currentUser = await this.getUser();
      const nursingID = currentUser?.nursingID;

      if (!nursingID) {
        console.log(
          "üîç No nursingID found, trying to get from getall endpoint"
        );
        // Fallback: s·ª≠ d·ª•ng getall ƒë·ªÉ t√¨m nursingID
        const token = await this.getToken();
        const response = await this.fetchWithTimeout(
          "http://localhost:5294/api/nursingspecialists/getall",
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );

        console.log(
          "üîç NursingSpecialist getall response status:",
          response.status
        );

        if (response.ok) {
          const data = await response.json();
          console.log("üîç All NursingSpecialists:", data);

          // T√¨m NursingSpecialist theo accountID
          const nursingSpecialist = data.find(
            (ns) => ns.accountID === accountID
          );

          if (nursingSpecialist) {
            console.log(
              "üîç Found NursingSpecialist:",
              nursingSpecialist
            );
            return { success: true, data: nursingSpecialist };
          } else {
            console.log(
              "üîç No NursingSpecialist found for accountID:",
              accountID
            );
            return {
              success: false,
              error: "Nursing specialist not found",
            };
          }
        } else {
          console.log(
            "üîç NursingSpecialist getall failed:",
            response.status
          );
          return {
            success: false,
            error: "Failed to fetch nursing specialists",
          };
        }
      } else {
        // C√≥ nursingID, l·∫•y th√¥ng tin chi ti·∫øt
        const token = await this.getToken();
        const response = await this.fetchWithTimeout(
          `http://localhost:5294/api/nursingspecialists/get/${nursingID}`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          console.log("üîç NursingSpecialist details:", data);
          return { success: true, data: data };
        } else {
          console.log(
            "üîç NursingSpecialist details fetch failed:",
            response.status
          );
          return {
            success: false,
            error: "Failed to fetch nursing specialist details",
          };
        }
      }
    } catch (error) {
      console.error(
        "üîç Error fetching NursingSpecialist details:",
        error
      );
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Enrich user data v·ªõi th√¥ng tin chi ti·∫øt c·ªßa NursingSpecialist
  async enrichNursingSpecialistData(userData) {
    try {
      console.log("üîç ===== ENRICHING NURSING SPECIALIST DATA =====");
      console.log("üîç Input userData:", userData);
      console.log("üîç Input userData keys:", Object.keys(userData));

      // N·∫øu ƒë√£ c√≥ ƒë·∫ßy ƒë·ªß th√¥ng tin th√¨ kh√¥ng c·∫ßn fetch
      if (userData.nursingID && userData.gender && userData.address) {
        console.log("üîç NursingSpecialist data already complete");
        console.log(
          "üîç Existing data - nursingID:",
          userData.nursingID,
          "gender:",
          userData.gender,
          "address:",
          userData.address
        );
        return userData;
      }

      console.log("üîç Data incomplete, fetching from API...");
      console.log(
        "üîç Missing fields - nursingID:",
        userData.nursingID,
        "gender:",
        userData.gender,
        "address:",
        userData.address
      );

      // Fetch th√¥ng tin chi ti·∫øt
      const result = await this.fetchNursingSpecialistDetails(
        userData.accountID
      );
      console.log("üîç Fetch result:", result);

      if (result.success) {
        const nursingData = result.data;
        console.log("üîç Nursing data from API:", nursingData);
        console.log(
          "üîç Nursing data keys:",
          Object.keys(nursingData)
        );

        // Merge th√¥ng tin m·ªõi v√†o user data
        const enrichedUserData = {
          ...userData,
          nursingID: nursingData.nursingID,
          zoneID: nursingData.zoneID,
          gender: nursingData.gender,
          dateOfBirth: nursingData.dateOfBirth,
          fullName: userData.fullName || nursingData.fullName, // ∆Øu ti√™n fullName t·ª´ login
          address: nursingData.address,
          experience: nursingData.experience,
          slogan: nursingData.slogan,
          major: nursingData.major,
          status: nursingData.status,
        };

        console.log("üîç Enriched user data:", enrichedUserData);
        console.log(
          "üîç Enriched user data keys:",
          Object.keys(enrichedUserData)
        );

        // L∆∞u l·∫°i user data ƒë√£ ƒë∆∞·ª£c enrich
        console.log("üîç Saving enriched data to AsyncStorage...");
        await this.saveUser(enrichedUserData);
        console.log("üîç Enriched data saved successfully");

        return enrichedUserData;
      } else {
        console.log(
          "üîç Failed to enrich NursingSpecialist data:",
          result.error
        );
        return userData; // Tr·∫£ v·ªÅ data c≈© n·∫øu kh√¥ng fetch ƒë∆∞·ª£c
      }
    } catch (error) {
      console.error(
        "üîç Error enriching NursingSpecialist data:",
        error
      );
      return userData; // Tr·∫£ v·ªÅ data c≈© n·∫øu c√≥ l·ªói
    }
  }

  // Ki·ªÉm tra k·∫øt n·ªëi API
  async checkApiConnection() {
    try {
      console.log("Checking API connection...");
      const response = await this.fetchWithTimeout(
        AUTH_ENDPOINTS.GET_ALL_ACCOUNTS,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        },
        5000 // 5 second timeout for connection check
      );

      const isConnected = response.ok;
      console.log(
        "API connection status:",
        isConnected ? "Connected" : "Failed"
      );
      return isConnected;
    } catch (error) {
      console.log("API connection failed:", error.message);
      return false;
    }
  }

  // Test API endpoints
  async testApiEndpoints() {
    const endpoints = [
      { name: "Login", url: AUTH_ENDPOINTS.LOGIN, method: "POST" },
      {
        name: "Register Customer",
        url: AUTH_ENDPOINTS.REGISTER_CUSTOMER,
        method: "POST",
      },
      {
        name: "Get All Accounts",
        url: AUTH_ENDPOINTS.GET_ALL_ACCOUNTS,
        method: "GET",
      },
    ];

    console.log("Testing API endpoints...");

    for (const endpoint of endpoints) {
      try {
        const response = await this.fetchWithTimeout(
          endpoint.url,
          {
            method: endpoint.method,
            headers: { "Content-Type": "application/json" },
          },
          3000
        );

        console.log(
          `${endpoint.name}: ${response.status} ${response.statusText}`
        );
      } catch (error) {
        console.log(`${endpoint.name}: Failed - ${error.message}`);
      }
    }
  }
}

// Export singleton instance
export default new AuthService();
